/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";var z=Object.defineProperty;var Q=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var Z=Object.prototype.hasOwnProperty;var ee=(c,e)=>{for(var t in e)z(c,t,{get:e[t],enumerable:!0})},te=(c,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of X(e))!Z.call(c,s)&&s!==t&&z(c,s,{get:()=>e[s],enumerable:!(n=Q(e,s))||n.enumerable});return c};var ne=c=>te(z({},"__esModule",{value:!0}),c);var re={};ee(re,{default:()=>O});module.exports=ne(re);var b=require("obsidian");var A={openaiApiKey:"",llmModel:"gpt-4o-mini",clusterCount:10,minMentionsForUndefined:2,sparseDensityThreshold:.3,excludeFolders:["06_Meta","09_Embedded","templates",".obsidian"],autoAnalyze:!1,analyzeIntervalDays:7,lastAnalyzedAt:null,maxGapsInReport:50,useKMeansPlusPlus:!0,enableLLMSuggestions:!0};var w=require("obsidian");var T=class extends w.PluginSettingTab{constructor(e,t){super(e,t),this.plugin=t}display(){let{containerEl:e}=this;e.empty(),e.createEl("h1",{text:"Knowledge Gap Detector"}),e.createEl("p",{text:"Detect knowledge gaps in your vault using embedding analysis and link graph.",cls:"setting-item-description"}),this.renderLLMSection(e),this.renderAnalysisSection(e),this.renderExclusionSection(e),this.renderAutoAnalysisSection(e),this.renderAdvancedSection(e)}renderLLMSection(e){e.createEl("h2",{text:"LLM Settings"}),new w.Setting(e).setName("OpenAI API Key").setDesc("API key for LLM-based topic inference and suggestions").addText(t=>t.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async n=>{this.plugin.settings.openaiApiKey=n,await this.plugin.saveSettings()})).addExtraButton(t=>t.setIcon("external-link").setTooltip("Get API key from OpenAI").onClick(()=>{window.open("https://platform.openai.com/api-keys","_blank")})),new w.Setting(e).setName("LLM Model").setDesc("Model to use for analysis (gpt-4o-mini is recommended for cost efficiency)").addDropdown(t=>t.addOption("gpt-4o-mini","GPT-4o Mini (Recommended)").addOption("gpt-4o","GPT-4o").addOption("gpt-4-turbo","GPT-4 Turbo").addOption("gpt-3.5-turbo","GPT-3.5 Turbo").setValue(this.plugin.settings.llmModel).onChange(async n=>{this.plugin.settings.llmModel=n,await this.plugin.saveSettings()})),new w.Setting(e).setName("Enable LLM Suggestions").setDesc("Use LLM to generate topic suggestions for gaps (requires API key)").addToggle(t=>t.setValue(this.plugin.settings.enableLLMSuggestions).onChange(async n=>{this.plugin.settings.enableLLMSuggestions=n,await this.plugin.saveSettings()}))}renderAnalysisSection(e){e.createEl("h2",{text:"Analysis Settings"}),new w.Setting(e).setName("Cluster Count").setDesc("Number of clusters for K-means analysis (default: 10). Higher values detect more granular gaps.").addSlider(t=>t.setLimits(3,30,1).setValue(this.plugin.settings.clusterCount).setDynamicTooltip().onChange(async n=>{this.plugin.settings.clusterCount=n,await this.plugin.saveSettings()})),new w.Setting(e).setName("Minimum Mentions for Undefined Concept").setDesc("Minimum times a [[concept]] must be mentioned to be flagged as undefined").addSlider(t=>t.setLimits(1,10,1).setValue(this.plugin.settings.minMentionsForUndefined).setDynamicTooltip().onChange(async n=>{this.plugin.settings.minMentionsForUndefined=n,await this.plugin.saveSettings()})),new w.Setting(e).setName("Sparse Density Threshold").setDesc("Regions with density below this threshold are flagged as sparse (0-1, lower is sparser)").addSlider(t=>t.setLimits(.1,.9,.1).setValue(this.plugin.settings.sparseDensityThreshold).setDynamicTooltip().onChange(async n=>{this.plugin.settings.sparseDensityThreshold=n,await this.plugin.saveSettings()})),new w.Setting(e).setName("Max Gaps in Report").setDesc("Maximum number of gaps to show in the analysis report").addSlider(t=>t.setLimits(10,100,10).setValue(this.plugin.settings.maxGapsInReport).setDynamicTooltip().onChange(async n=>{this.plugin.settings.maxGapsInReport=n,await this.plugin.saveSettings()}))}renderExclusionSection(e){e.createEl("h2",{text:"Exclusion Settings"}),new w.Setting(e).setName("Exclude Folders").setDesc("Folders to exclude from analysis (comma-separated)").addTextArea(t=>t.setPlaceholder("templates, .obsidian, archive").setValue(this.plugin.settings.excludeFolders.join(", ")).onChange(async n=>{this.plugin.settings.excludeFolders=n.split(",").map(s=>s.trim()).filter(s=>s.length>0),await this.plugin.saveSettings()}))}renderAutoAnalysisSection(e){if(e.createEl("h2",{text:"Auto-Analysis"}),new w.Setting(e).setName("Enable Auto-Analysis").setDesc("Automatically run gap analysis on a schedule").addToggle(t=>t.setValue(this.plugin.settings.autoAnalyze).onChange(async n=>{this.plugin.settings.autoAnalyze=n,await this.plugin.saveSettings()})),new w.Setting(e).setName("Analysis Interval (Days)").setDesc("How often to run automatic analysis").addSlider(t=>t.setLimits(1,30,1).setValue(this.plugin.settings.analyzeIntervalDays).setDynamicTooltip().onChange(async n=>{this.plugin.settings.analyzeIntervalDays=n,await this.plugin.saveSettings()})),this.plugin.settings.lastAnalyzedAt){let t=new Date(this.plugin.settings.lastAnalyzedAt);e.createEl("p",{text:`Last analyzed: ${t.toLocaleDateString()} ${t.toLocaleTimeString()}`,cls:"setting-item-description"})}}renderAdvancedSection(e){e.createEl("h2",{text:"Advanced Settings"}),new w.Setting(e).setName("Use K-Means++ Initialization").setDesc("Use K-Means++ for better cluster initialization (recommended)").addToggle(t=>t.setValue(this.plugin.settings.useKMeansPlusPlus).onChange(async n=>{this.plugin.settings.useKMeansPlusPlus=n,await this.plugin.saveSettings()})),new w.Setting(e).setName("Reset to Defaults").setDesc("Reset all settings to their default values").addButton(t=>t.setButtonText("Reset").setWarning().onClick(async()=>{let n=this.plugin.settings.openaiApiKey;this.plugin.settings={...A,openaiApiKey:n},await this.plugin.saveSettings(),this.display()}))}};var v=require("obsidian");var se={includeTimestamp:!0,includeSummary:!0,maxGapsToShow:20,maxSparseRegions:10,maxUndefinedConcepts:15,showRelatedNotes:!0,showSuggestedTopics:!0},M=class{formatReport(e,t={}){let n={...se,...t},s=[];return s.push(`# Knowledge Gap Analysis Report
`),n.includeTimestamp&&s.push(`*Generated: ${e.analyzedAt.toLocaleString()}*
`),n.includeSummary&&s.push(this.formatSummary(e)),e.gaps.length>0&&s.push(this.formatGaps(e.gaps,n)),e.sparseRegions.length>0&&s.push(this.formatSparseRegions(e.sparseRegions,n)),e.undefinedConcepts.length>0&&s.push(this.formatUndefinedConcepts(e.undefinedConcepts,n)),s.push(this.formatFooter()),s.join(`
`)}formatSummary(e){let{gaps:t,sparseRegions:n,undefinedConcepts:s}=e,i={significant:t.filter(o=>o.severity==="significant").length,moderate:t.filter(o=>o.severity==="moderate").length,minor:t.filter(o=>o.severity==="minor").length},r={sparse_region:t.filter(o=>o.type==="sparse_region").length,undefined_concept:t.filter(o=>o.type==="undefined_concept").length,weak_connection:t.filter(o=>o.type==="weak_connection").length};return`## Summary

| Metric | Count |
|--------|-------|
| Total Gaps Detected | ${t.length} |
| Sparse Regions | ${n.length} |
| Undefined Concepts | ${s.length} |

### By Severity
- \u{1F534} **Significant**: ${i.significant}
- \u{1F7E1} **Moderate**: ${i.moderate}
- \u{1F7E2} **Minor**: ${i.minor}

### By Type
- \u{1F5FA}\uFE0F Sparse Regions: ${r.sparse_region}
- \u2753 Undefined Concepts: ${r.undefined_concept}
- \u{1F517} Weak Connections: ${r.weak_connection}
`}formatGaps(e,t){let n=e.slice(0,t.maxGapsToShow),s=[`## Top Knowledge Gaps
`];for(let i of n)s.push(this.formatSingleGap(i,t));return e.length>(t.maxGapsToShow||20)&&s.push(`
*...and ${e.length-(t.maxGapsToShow||20)} more gaps*
`),s.join(`
`)}formatSingleGap(e,t){let n=this.getSeverityIcon(e.severity),s=this.getTypeIcon(e.type),i=[`### ${n} ${e.title}`,"",`**Type**: ${s} ${this.formatGapType(e.type)}`,`**Severity**: ${this.formatSeverity(e.severity)}`,"",e.description,""];if(t.showSuggestedTopics&&e.suggestedTopics.length>0){i.push("**Suggested Topics to Explore**:");for(let r of e.suggestedTopics.slice(0,5))i.push(`- ${r}`);i.push("")}if(t.showRelatedNotes&&e.relatedNotes.length>0){i.push("**Related Notes**:");for(let r of e.relatedNotes.slice(0,5))i.push(`- [[${this.extractNoteName(r)}]]`);i.push("")}return i.join(`
`)}formatSparseRegions(e,t){let n=e.slice(0,t.maxSparseRegions),s=[`## Sparse Regions
`];s.push(`These are areas in your knowledge graph with low note density - potential areas for expansion.
`);for(let i=0;i<n.length;i++){let r=n[i];s.push(this.formatSingleSparseRegion(r,i+1))}return e.length>(t.maxSparseRegions||10)&&s.push(`
*...and ${e.length-(t.maxSparseRegions||10)} more sparse regions*
`),s.join(`
`)}formatSingleSparseRegion(e,t){let n=(e.density*100).toFixed(1),s=this.getDensityBar(e.density),i=[`### ${t}. ${e.inferredTopic||`Region ${e.id}`}`,"",`**Density**: ${s} ${n}%`,`**Notes in Area**: ${e.noteCount}`,""];if(e.nearestNotes.length>0){i.push("**Nearest Notes**:");for(let r of e.nearestNotes.slice(0,3))i.push(`- [[${this.extractNoteName(r.notePath)}]] (distance: ${r.distance.toFixed(3)})`);i.push("")}if(e.boundaryNotes.length>0){i.push("**Boundary Notes** (potential bridges):");for(let r of e.boundaryNotes.slice(0,3))i.push(`- [[${this.extractNoteName(r)}]]`);i.push("")}return i.join(`
`)}formatUndefinedConcepts(e,t){let n=e.slice(0,t.maxUndefinedConcepts),s=[`## Undefined Concepts
`];s.push(`These concepts are referenced in your notes but don't have dedicated notes yet.
`),s.push("| Concept | Mentions | Sources |"),s.push("|---------|----------|---------|");for(let i of n){let r=i.mentionedIn.slice(0,3).map(l=>this.extractNoteName(l)).join(", "),o=i.mentionedIn.length>3?"...":"";s.push(`| [[${i.name}]] | ${i.mentionCount} | ${r}${o} |`)}e.length>(t.maxUndefinedConcepts||15)&&s.push(`
*...and ${e.length-(t.maxUndefinedConcepts||15)} more undefined concepts*
`),s.push(`
### Quick Actions
`),s.push(`Top 5 concepts to define (by mention count):
`);for(let i of e.slice(0,5))s.push(`1. **[[${i.name}]]** - mentioned ${i.mentionCount} times`),i.relatedConcepts.length>0&&s.push(`   - Related to: ${i.relatedConcepts.slice(0,3).join(", ")}`);return s.push(""),s.join(`
`)}formatFooter(){return`---

## Next Steps

1. **Review significant gaps** - Start with \u{1F534} marked items
2. **Create notes for top undefined concepts** - Build foundational knowledge
3. **Explore sparse regions** - Consider what topics might bridge existing notes
4. **Re-run analysis** - After creating new notes to track progress

---
*Generated by Knowledge Gap Detector*
`}getSeverityIcon(e){switch(e){case"significant":return"\u{1F534}";case"moderate":return"\u{1F7E1}";case"minor":return"\u{1F7E2}";default:return"\u26AA"}}getTypeIcon(e){switch(e){case"sparse_region":return"\u{1F5FA}\uFE0F";case"undefined_concept":return"\u2753";case"weak_connection":return"\u{1F517}";default:return"\u{1F4DD}"}}formatGapType(e){switch(e){case"sparse_region":return"Sparse Region";case"undefined_concept":return"Undefined Concept";case"weak_connection":return"Weak Connection";default:return e}}formatSeverity(e){return e.charAt(0).toUpperCase()+e.slice(1)}getDensityBar(e){let t=Math.round(e*10),n=10-t;return"\u2588".repeat(t)+"\u2591".repeat(n)}extractNoteName(e){let t=e.split("/");return t[t.length-1].replace(/\.md$/,"")}formatQuickSummary(e){let{gaps:t,sparseRegions:n,undefinedConcepts:s}=e,i=t.filter(r=>r.severity==="significant").length;return`**${t.length}** gaps detected (${i} significant)
**${n.length}** sparse regions found
**${s.length}** undefined concepts`}formatGapListItem(e){let t=this.getSeverityIcon(e.severity),n=this.getTypeIcon(e.type);return`${t} ${n} **${e.title}**
   ${e.description.slice(0,100)}${e.description.length>100?"...":""}`}};var S=class extends v.Modal{constructor(t,n){super(t);this.activeTab="overview";this.report=n,this.presenter=new M}onOpen(){let{contentEl:t,modalEl:n}=this;n.addClass("knowledge-gap-modal"),this.renderHeader(t),this.renderTabs(t);let s=t.createDiv({cls:"gap-report-content"});this.renderTabContent(s)}onClose(){this.contentEl.empty()}renderHeader(t){let n=t.createDiv({cls:"gap-report-header"}),s=n.createDiv({cls:"gap-report-title-container"}),i=s.createSpan({cls:"gap-report-icon"});(0,v.setIcon)(i,"search"),s.createEl("h2",{text:"Knowledge Gap Analysis"});let r=n.createDiv({cls:"gap-report-stats"}),o=this.report.gaps.filter(d=>d.severity==="significant").length;this.createStatBadge(r,"Total Gaps",this.report.gaps.length.toString(),"search"),this.createStatBadge(r,"Significant",o.toString(),"alert-circle"),this.createStatBadge(r,"Sparse Regions",this.report.sparseRegions.length.toString(),"map"),this.createStatBadge(r,"Undefined",this.report.undefinedConcepts.length.toString(),"help-circle");let a=n.createDiv({cls:"gap-report-actions"}).createEl("button",{text:"Export as Markdown",cls:"mod-cta"});a.onclick=()=>this.exportReport()}createStatBadge(t,n,s,i){let r=t.createDiv({cls:"stat-badge"}),o=r.createSpan({cls:"stat-icon"});(0,v.setIcon)(o,i),r.createSpan({cls:"stat-value",text:s}),r.createSpan({cls:"stat-label",text:n})}renderTabs(t){let n=t.createDiv({cls:"gap-report-tabs"}),s=[{id:"overview",label:"Overview",icon:"layout-dashboard"},{id:"gaps",label:"Top Gaps",icon:"alert-triangle"},{id:"sparse",label:"Sparse Regions",icon:"map"},{id:"undefined",label:"Undefined Concepts",icon:"help-circle"}];for(let i of s){let r=n.createDiv({cls:`gap-report-tab ${this.activeTab===i.id?"active":""}`}),o=r.createSpan({cls:"tab-icon"});(0,v.setIcon)(o,i.icon),r.createSpan({text:i.label}),r.onclick=()=>{this.activeTab=i.id,this.refreshContent()}}}refreshContent(){let{contentEl:t}=this;t.querySelectorAll(".gap-report-tab").forEach((i,r)=>{let o=["overview","gaps","sparse","undefined"];i.removeClass("active"),o[r]===this.activeTab&&i.addClass("active")});let s=t.querySelector(".gap-report-content");s&&(s.empty(),this.renderTabContent(s))}renderTabContent(t){switch(this.activeTab){case"overview":this.renderOverview(t);break;case"gaps":this.renderGapsList(t);break;case"sparse":this.renderSparseRegions(t);break;case"undefined":this.renderUndefinedConcepts(t);break}}renderOverview(t){let n=t.createDiv({cls:"gap-overview"}),s=n.createDiv({cls:"overview-section"});s.createEl("h3",{text:"Summary"});let i=s.createDiv({cls:"summary-grid"}),r=i.createDiv({cls:"summary-card"});r.createEl("h4",{text:"By Severity"});let o=["significant","moderate","minor"],l={significant:"\u{1F534}",moderate:"\u{1F7E1}",minor:"\u{1F7E2}"};for(let m of o){let f=this.report.gaps.filter(y=>y.severity===m).length;r.createEl("p",{text:`${l[m]} ${m.charAt(0).toUpperCase()+m.slice(1)}: ${f}`})}let a=i.createDiv({cls:"summary-card"});a.createEl("h4",{text:"By Type"});let d=["sparse_region","undefined_concept","weak_connection"],p={sparse_region:"\u{1F5FA}\uFE0F Sparse Regions",undefined_concept:"\u2753 Undefined Concepts",weak_connection:"\u{1F517} Weak Connections"};for(let m of d){let f=this.report.gaps.filter(y=>y.type===m).length;a.createEl("p",{text:`${p[m]}: ${f}`})}let h=n.createDiv({cls:"overview-section"});h.createEl("h3",{text:"Top Recommendations"});let u=this.report.gaps.slice(0,5);if(u.length===0)h.createEl("p",{text:"No significant gaps detected. Your knowledge base looks healthy!",cls:"no-gaps-message"});else{let m=h.createEl("ol",{cls:"recommendations-list"});for(let f of u){let y=m.createEl("li");y.createEl("strong",{text:f.title}),y.createEl("span",{text:` - ${f.description.slice(0,100)}...`})}}n.createDiv({cls:"overview-section analysis-info"}).createEl("p",{text:`Analysis completed: ${this.report.analyzedAt.toLocaleString()}`,cls:"analysis-timestamp"})}renderGapsList(t){let n=t.createDiv({cls:"gaps-list"});if(this.report.gaps.length===0){n.createEl("p",{text:"No knowledge gaps detected.",cls:"empty-message"});return}for(let s of this.report.gaps)this.renderGapCard(n,s)}renderGapCard(t,n){var l;let s=t.createDiv({cls:`gap-card severity-${n.severity}`}),i=s.createDiv({cls:"gap-card-header"}),r=this.getSeverityIcon(n.severity),o=this.getTypeIcon(n.type);if(i.createEl("span",{text:`${r} ${o}`,cls:"gap-icons"}),i.createEl("h4",{text:n.title}),s.createEl("p",{text:n.description,cls:"gap-description"}),n.suggestedTopics.length>0){let a=s.createDiv({cls:"gap-topics"});a.createEl("strong",{text:"Explore: "}),a.createEl("span",{text:n.suggestedTopics.slice(0,3).join(", ")})}if(n.relatedNotes.length>0){let a=s.createDiv({cls:"gap-related"});a.createEl("strong",{text:"Related: "});for(let d of n.relatedNotes.slice(0,3)){let p=((l=d.split("/").pop())==null?void 0:l.replace(".md",""))||d,h=a.createEl("a",{text:p,cls:"internal-link"});h.onclick=u=>{u.preventDefault(),this.app.workspace.openLinkText(d,"")},a.createEl("span",{text:" "})}}}renderSparseRegions(t){let n=t.createDiv({cls:"sparse-list"});if(this.report.sparseRegions.length===0){n.createEl("p",{text:"No sparse regions detected. Your knowledge coverage is good!",cls:"empty-message"});return}for(let s=0;s<this.report.sparseRegions.length;s++)this.renderSparseRegionCard(n,this.report.sparseRegions[s],s+1)}renderSparseRegionCard(t,n,s){var d;let i=t.createDiv({cls:"sparse-card"}),r=i.createDiv({cls:"sparse-card-header"});r.createEl("span",{text:`#${s}`,cls:"sparse-index"}),r.createEl("h4",{text:n.inferredTopic||`Region ${n.id}`});let o=i.createDiv({cls:"density-container"});o.createEl("span",{text:"Density: ",cls:"density-label"});let a=o.createDiv({cls:"density-bar"}).createDiv({cls:"density-fill"});if(a.style.width=`${n.density*100}%`,o.createEl("span",{text:`${(n.density*100).toFixed(1)}%`,cls:"density-value"}),n.nearestNotes.length>0){let p=i.createDiv({cls:"nearby-notes"});p.createEl("strong",{text:"Nearby Notes: "});for(let h of n.nearestNotes.slice(0,3)){let u=((d=h.notePath.split("/").pop())==null?void 0:d.replace(".md",""))||h.notePath,g=p.createEl("a",{text:u,cls:"internal-link"});g.onclick=m=>{m.preventDefault(),this.app.workspace.openLinkText(h.notePath,"")},p.createEl("span",{text:" "})}}}renderUndefinedConcepts(t){let n=t.createDiv({cls:"undefined-list"});if(this.report.undefinedConcepts.length===0){n.createEl("p",{text:"No undefined concepts found. All referenced concepts have dedicated notes!",cls:"empty-message"});return}let s=n.createEl("table",{cls:"undefined-table"}),r=s.createEl("thead").createEl("tr");r.createEl("th",{text:"Concept"}),r.createEl("th",{text:"Mentions"}),r.createEl("th",{text:"Sources"}),r.createEl("th",{text:"Action"});let o=s.createEl("tbody");for(let l of this.report.undefinedConcepts)this.renderUndefinedConceptRow(o,l)}renderUndefinedConceptRow(t,n){var d;let s=t.createEl("tr");s.createEl("td").createEl("strong",{text:n.name}),s.createEl("td",{text:n.mentionCount.toString()});let r=s.createEl("td"),o=n.mentionedIn.slice(0,2);for(let p of o){let h=((d=p.split("/").pop())==null?void 0:d.replace(".md",""))||p,u=r.createEl("a",{text:h,cls:"internal-link"});u.onclick=g=>{g.preventDefault(),this.app.workspace.openLinkText(p,"")},r.createEl("span",{text:" "})}n.mentionedIn.length>2&&r.createEl("span",{text:`+${n.mentionedIn.length-2} more`});let a=s.createEl("td").createEl("button",{text:"Create Note",cls:"mod-cta"});a.onclick=()=>this.createNoteForConcept(n)}async createNoteForConcept(t){let n=`# ${t.name}

<!-- TODO: Define this concept -->

## Related Concepts

${t.relatedConcepts.slice(0,5).map(i=>`- [[${i}]]`).join(`
`)}

## Mentioned In

${t.mentionedIn.slice(0,10).map(i=>{var r;return`- [[${((r=i.split("/").pop())==null?void 0:r.replace(".md",""))||i}]]`}).join(`
`)}
`,s=(0,v.normalizePath)(`${t.name}.md`);try{await this.app.vault.create(s,n),new v.Notice(`Created note: ${t.name}`),await this.app.workspace.openLinkText(s,"")}catch(i){let r=i instanceof Error?i.message:String(i);r.includes("already exists")||r.includes("File exists")?(new v.Notice(`Note already exists: ${t.name}`),await this.app.workspace.openLinkText(s,"")):new v.Notice(`Failed to create note: ${r}`)}}async exportReport(){let t=this.presenter.formatReport(this.report),n=(0,v.normalizePath)(`Knowledge-Gap-Report-${new Date().toISOString().split("T")[0]}.md`);try{await this.app.vault.create(n,t),new v.Notice(`Report exported: ${n}`),await this.app.workspace.openLinkText(n,"")}catch(s){let i=s instanceof Error?s.message:String(s);i.includes("already exists")||i.includes("File exists")?(new v.Notice(`Report file already exists, opening: ${n}`),await this.app.workspace.openLinkText(n,"")):new v.Notice(`Failed to export report: ${i}`)}}getSeverityIcon(t){switch(t){case"significant":return"\u{1F534}";case"moderate":return"\u{1F7E1}";case"minor":return"\u{1F7E2}";default:return"\u26AA"}}getTypeIcon(t){switch(t){case"sparse_region":return"\u{1F5FA}\uFE0F";case"undefined_concept":return"\u2753";case"weak_connection":return"\u{1F517}";default:return"\u{1F4DD}"}}};function K(c){return{id:c.id,type:c.type,title:c.title,description:c.description,severity:c.severity,suggestedTopics:c.suggestedTopics||[],relatedNotes:c.relatedNotes||[],detectedAt:new Date}}function B(c){return{id:c.id,centroid:c.centroid,density:c.density,nearestNotes:c.nearestNotes,boundaryNotes:c.boundaryNotes||[],noteCount:c.noteCount,inferredTopic:c.inferredTopic}}var k=class{constructor(e,t){this.embeddingReader=e;this.clusteringService=t}async execute(e={}){let{clusterCount:t,sparsityThreshold:n=.3,maxRegions:s=10,excludeFolders:i=[]}=e,r=await this.embeddingReader.readAllEmbeddings();if(r.size===0)return[];let o=this.filterExcludedFolders(r,i);if(o.size<3)return[];let l=new Map;for(let[u,g]of o)l.set(u,g.vector);let d={k:t||this.calculateOptimalK(l.size),maxIterations:100,tolerance:1e-4,useKMeansPlusPlus:!0},p=this.clusteringService.kMeans(l,d),h=[];for(let u of p.clusters){let g=this.clusteringService.calculateDensity(u,l);if(g<n){let m=this.findNearestNotes(u,o),f=this.findBoundaryNotes(u,o),y=B({id:u.id,centroid:u.centroid,density:g,nearestNotes:m,boundaryNotes:f,noteCount:u.members.length});h.push(y)}}return h.sort((u,g)=>u.density-g.density).slice(0,s)}filterExcludedFolders(e,t){if(t.length===0)return e;let n=new Map;for(let[s,i]of e)t.some(o=>i.notePath.startsWith(o))||n.set(s,i);return n}calculateOptimalK(e){let t=Math.round(Math.sqrt(e/2));return Math.max(3,Math.min(20,t))}findNearestNotes(e,t){let n=[];for(let s of e.members){let i=t.get(s);if(i){let r=this.clusteringService.euclideanDistance(i.vector,e.centroid);n.push({notePath:i.notePath,distance:r})}}return n.sort((s,i)=>s.distance-i.distance)}findBoundaryNotes(e,t){let n=this.findNearestNotes(e,t),s=Math.min(3,Math.ceil(n.length*.2));return n.slice(-s).map(i=>i.notePath)}};function V(c){return{name:c.name,mentionCount:c.mentionCount,mentionedIn:c.mentionedIn,relatedConcepts:c.relatedConcepts||[],suggestedContent:c.suggestedContent}}var R=class{constructor(e){this.linkGraphReader=e}async execute(e={}){let{minMentions:t=2,maxConcepts:n=50,analyzeCoOccurrence:s=!0,excludeFolders:i=[]}=e,r=await this.linkGraphReader.getUndefinedLinks(),o=this.filterLinks(r,t,i),l=[];for(let a of o){let d=[];s&&(d=this.linkGraphReader.getCoOccurringConcepts(a.linkText,2));let p=V({name:a.linkText,mentionCount:a.count,mentionedIn:a.sources,relatedConcepts:d});l.push(p)}return l.sort((a,d)=>d.mentionCount-a.mentionCount).slice(0,n)}filterLinks(e,t,n){return e.filter(s=>!(s.count<t||n.length>0&&s.sources.filter(r=>!n.some(o=>r.startsWith(o))).length<t||this.isSystemLink(s.linkText)))}isSystemLink(e){return[/^Template/i,/^_/,/^\d{4}-\d{2}-\d{2}$/,/^MOC$/i,/^Index$/i,/^README$/i,/^TODO$/i,/^CHANGELOG$/i].some(n=>n.test(e))}};var G=class{constructor(e){this.llmService=e}async execute(e){return this.llmService.isAvailable()?this.llmService.generateExplorationSuggestions(e.description,e.relatedNotes,this.buildContext(e)):this.generateFallbackSuggestions(e)}async inferTopicForRegion(e,t){return this.llmService.isAvailable()?(await this.llmService.inferTopic(t)).topic:void 0}async suggestContentForConcept(e){if(this.llmService.isAvailable())return this.llmService.describeUndefinedConcept(e.name,e.mentionedIn)}buildContext(e){let t=[];return t.push(`Gap Type: ${e.type}`),t.push(`Severity: ${e.severity}`),e.relatedNotes.length>0&&t.push(`Related Notes: ${e.relatedNotes.slice(0,5).join(", ")}`),e.suggestedTopics.length>0&&t.push(`Initial Suggestions: ${e.suggestedTopics.join(", ")}`),t.join(`
`)}generateFallbackSuggestions(e){let t=[];switch(e.type){case"sparse_region":t.push({topic:e.title,questions:["What are the key concepts in this area?","How does this relate to your existing knowledge?","What resources could help you learn more?"],subtopics:e.suggestedTopics.slice(0,3),rationale:"This area has fewer notes compared to other parts of your knowledge base."});break;case"undefined_concept":t.push({topic:e.title,questions:[`What is ${e.title}?`,`Why is ${e.title} mentioned in your notes?`,`How does ${e.title} connect to your existing knowledge?`],subtopics:[],rationale:"This concept is frequently referenced but not yet documented."});break;case"weak_connection":t.push({topic:e.title,questions:["What bridges these isolated concepts?","Are there hidden relationships to explore?"],subtopics:e.suggestedTopics,rationale:"This area could benefit from better connections to other knowledge."});break}return t}};function $(c){return(c.split("/").pop()||c).replace(/\.md$/,"")}var L=class{constructor(e,t,n,s){this.embeddingReader=e;this.llmService=s;this.cancelled=!1;this.detectSparseRegions=new k(e,n),this.findUndefinedConcepts=new R(t),this.suggestExploration=new G(s)}onProgress(e){this.progressCallback=e}cancel(){this.cancelled=!0}async execute(e={}){this.cancelled=!1;let{clusterCount:t,minMentions:n=2,sparsityThreshold:s=.3,excludeFolders:i=[],useLLM:r=!0,maxGaps:o=50}=e;if(this.reportProgress("loading",0,"Loading embeddings..."),!await this.embeddingReader.isAvailable())throw new Error("Vault Embeddings data not found. Please ensure Vault Embeddings plugin is installed and has indexed your vault.");let a=await this.embeddingReader.getEmbeddingCount();if(this.reportProgress("loading",20,`Found ${a} embedded notes`),this.cancelled)return this.createEmptyReport(e);this.reportProgress("clustering",25,"Analyzing embedding clusters...");let d=await this.detectSparseRegions.execute({clusterCount:t,sparsityThreshold:s,excludeFolders:i});if(this.reportProgress("clustering",50,`Found ${d.length} sparse regions`),this.cancelled)return this.createEmptyReport(e);this.reportProgress("analyzing_links",55,"Analyzing link graph...");let p=await this.findUndefinedConcepts.execute({minMentions:n,excludeFolders:i});if(this.reportProgress("analyzing_links",70,`Found ${p.length} undefined concepts`),this.cancelled)return this.createEmptyReport(e);let h=d,u=p;if(r&&this.llmService.isAvailable()&&(this.reportProgress("generating_suggestions",75,"Generating topic suggestions..."),h=await this.enrichSparseRegions(d),this.reportProgress("generating_suggestions",85,"Enriching concepts..."),u=await this.enrichUndefinedConcepts(p.slice(0,10))),this.cancelled)return this.createEmptyReport(e);this.reportProgress("generating_suggestions",90,"Creating gap report...");let g=this.createKnowledgeGaps(h,u),m=this.sortGapsByPriority(g).slice(0,o);return this.reportProgress("complete",100,"Analysis complete"),{analyzedAt:new Date,totalNotesAnalyzed:a,totalEmbeddings:a,sparseRegions:h,undefinedConcepts:u,gaps:m,options:e}}reportProgress(e,t,n){this.progressCallback&&this.progressCallback({phase:e,progress:t,message:n})}async enrichSparseRegions(e){let t=[];for(let n of e){if(this.cancelled)break;let s=n.nearestNotes.slice(0,5).map(r=>$(r.notePath)),i=await this.suggestExploration.inferTopicForRegion(n,s);t.push({...n,inferredTopic:i||`Cluster ${n.id}`})}return t}async enrichUndefinedConcepts(e){let t=[];for(let n of e){if(this.cancelled)break;let s=await this.suggestExploration.suggestContentForConcept(n);t.push({...n,suggestedContent:s})}return t}createKnowledgeGaps(e,t){let n=[];for(let s of e){let i=this.calculateSparseRegionSeverity(s);n.push(K({id:`sparse-${s.id}`,type:"sparse_region",title:s.inferredTopic||`Low Coverage Area ${s.id}`,description:`This area of your knowledge base has low note density (${(s.density*100).toFixed(1)}%). Consider exploring topics related to: ${s.nearestNotes.slice(0,3).map(r=>$(r.notePath)).join(", ")}.`,severity:i,suggestedTopics:s.nearestNotes.slice(0,5).map(r=>$(r.notePath)),relatedNotes:s.nearestNotes.slice(0,10).map(r=>r.notePath)}))}for(let s of t){let i=this.calculateConceptSeverity(s);n.push(K({id:`undefined-${s.name.replace(/\s+/g,"-").toLowerCase()}`,type:"undefined_concept",title:s.name,description:`"${s.name}" is mentioned ${s.mentionCount} times but has no dedicated note.${s.suggestedContent?` Suggested focus: ${s.suggestedContent.slice(0,100)}...`:""}`,severity:i,suggestedTopics:s.relatedConcepts.slice(0,5),relatedNotes:s.mentionedIn.slice(0,10)}))}return n}calculateSparseRegionSeverity(e){return e.density<.1?"significant":e.density<.2?"moderate":"minor"}calculateConceptSeverity(e){return e.mentionCount>=10?"significant":e.mentionCount>=5?"moderate":"minor"}sortGapsByPriority(e){let t={significant:3,moderate:2,minor:1};return[...e].sort((n,s)=>{let i=t[s.severity]-t[n.severity];return i!==0?i:n.type==="undefined_concept"&&s.type!=="undefined_concept"?-1:s.type==="undefined_concept"&&n.type!=="undefined_concept"?1:0})}createEmptyReport(e){return{analyzedAt:new Date,totalNotesAnalyzed:0,totalEmbeddings:0,sparseRegions:[],undefinedConcepts:[],gaps:[],options:e}}};var I=require("obsidian"),_="09_Embedded",j="index.json",ie="embeddings",N=class{constructor(e){this.vault=e;this.cachedIndex=null;this.embeddingsCache=new Map}async isAvailable(){let e=(0,I.normalizePath)(`${_}/${j}`);return this.vault.getAbstractFileByPath(e)!==null}async readIndex(){if(this.cachedIndex)return this.cachedIndex;let e=(0,I.normalizePath)(`${_}/${j}`);try{if(!this.vault.getAbstractFileByPath(e)&&!await this.vault.adapter.exists(e))return null;let n=await this.vault.adapter.read(e);return this.cachedIndex=JSON.parse(n),this.cachedIndex}catch(t){return console.error("Failed to read embedding index:",t),null}}async readEmbedding(e){let t=this.embeddingsCache.get(e);if(t)return t;let n=(0,I.normalizePath)(`${_}/${ie}/${e}.json`);try{if(!await this.vault.adapter.exists(n))return null;let i=await this.vault.adapter.read(n),r=JSON.parse(i);return this.embeddingsCache.set(e,r),r}catch(s){return console.error(`Failed to read embedding for ${e}:`,s),null}}async readAllEmbeddings(){if(this.embeddingsCache.size>0)return this.embeddingsCache;let e=await this.readIndex();if(!e)return new Map;let t=new Map,n=Object.keys(e.notes),s=50;for(let i=0;i<n.length;i+=s){let r=n.slice(i,i+s),o=await Promise.all(r.map(l=>this.readEmbedding(l)));for(let l=0;l<r.length;l++){let a=o[l];a&&t.set(r[l],a)}}return this.embeddingsCache=t,t}async getEmbeddingCount(){let e=await this.readIndex();return e?e.totalNotes:0}clearCache(){this.cachedIndex=null,this.embeddingsCache.clear()}async getEmbeddingByPath(e){let t=await this.readIndex();if(!t)return null;for(let[n,s]of Object.entries(t.notes))if(s.path===e)return this.readEmbedding(n);return null}};var H=require("obsidian"),q=/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g,D=class{constructor(e){this.vault=e;this.linkGraph=null;this.excludeFolders=[]}setExcludeFolders(e){this.excludeFolders=e,this.linkGraph=null}async buildGraph(){if(this.linkGraph)return this.linkGraph;let e=new Map,t=new Map,n=new Map,s=this.vault.getMarkdownFiles(),i=new Set;for(let r of s){let o=r.path.replace(/\.md$/,"");i.add(o),i.add(r.basename)}for(let r of s){if(this.shouldExclude(r.path))continue;let o=await this.vault.cachedRead(r),l=this.extractLinks(o),a=this.extractTags(o);e.set(r.path,{path:r.path,outgoingLinks:l,tags:a});for(let d of l){let p=this.normalizeLinkTarget(d);if(i.has(p)||i.has(d)){let u=this.findNotePath(p,s)||p,g=t.get(u)||new Set;g.add(r.path),t.set(u,g)}else{let u=n.get(d);u?(u.count++,u.sources.includes(r.path)||u.sources.push(r.path)):n.set(d,{linkText:d,sources:[r.path],count:1})}}}return this.linkGraph={notes:e,incomingLinks:t,undefinedLinks:n},this.linkGraph}async getUndefinedLinks(){let e=await this.buildGraph();return Array.from(e.undefinedLinks.values())}getLinkFrequency(e){if(!this.linkGraph)return 0;let t=this.linkGraph.undefinedLinks.get(e);if(t)return t.count;let n=this.linkGraph.incomingLinks.get(e);return n?n.size:0}getNotesMentioning(e){if(!this.linkGraph)return[];let t=this.linkGraph.undefinedLinks.get(e);if(t)return t.sources;let n=this.linkGraph.incomingLinks.get(e);return n?Array.from(n):[]}getCoOccurringConcepts(e,t=2){if(!this.linkGraph)return[];let n=this.getNotesMentioning(e);if(n.length===0)return[];let s=new Map;for(let i of n){let r=this.linkGraph.notes.get(i);if(r)for(let o of r.outgoingLinks)o!==e&&s.set(o,(s.get(o)||0)+1)}return Array.from(s.entries()).filter(([i,r])=>r>=t).sort((i,r)=>r[1]-i[1]).map(([i])=>i)}clearCache(){this.linkGraph=null}shouldExclude(e){return this.excludeFolders.some(t=>e.startsWith((0,H.normalizePath)(t)))}extractLinks(e){let t=[],n;for(q.lastIndex=0;(n=q.exec(e))!==null;){let s=n[1].trim();s&&!t.includes(s)&&t.push(s)}return t}extractTags(e){let t=[],n=/(?:^|\s)#([a-zA-Z0-9_\-/]+)/g,s;for(;(s=n.exec(e))!==null;){let i=s[1];i&&!t.includes(i)&&t.push(i)}return t}normalizeLinkTarget(e){return e.split("/").pop()||e}findNotePath(e,t){for(let n of t)if(n.basename===e||n.path===e+".md")return n.path}};function W(c,e){if(c.length!==e.length)throw new Error(`Vector length mismatch: ${c.length} vs ${e.length}`);let t=0,n=0,s=0;for(let r=0;r<c.length;r++)t+=c[r]*e[r],n+=c[r]*c[r],s+=e[r]*e[r];let i=Math.sqrt(n)*Math.sqrt(s);return i===0?0:t/i}function C(c,e){if(c.length!==e.length)throw new Error(`Vector length mismatch: ${c.length} vs ${e.length}`);let t=0;for(let n=0;n<c.length;n++){let s=c[n]-e[n];t+=s*s}return Math.sqrt(t)}function P(c){if(c.length===0)throw new Error("Cannot calculate centroid of empty vector set");let e=c[0].length,t=new Array(e).fill(0);for(let n of c)for(let s=0;s<e;s++)t[s]+=n[s];for(let n=0;n<e;n++)t[n]/=c.length;return t}var U=class{kMeans(e,t){let{k:n,maxIterations:s=100,tolerance:i=1e-4,useKMeansPlusPlus:r=!0}=t;if(e.size===0)return{clusters:[],assignments:new Map};if(e.size<n)return this.createSinglePointClusters(e);let o=Array.from(e.entries()),l=o.map(([f])=>f),a=o.map(([,f])=>f),d;r?d=this.kMeansPlusPlusInit(a,n):d=this.randomInit(a,n);let p=new Array(a.length).fill(0),h=0,u=!1;for(;h<s&&!u;){let f=a.map(y=>this.findNearestCentroid(y,d));if(u=this.assignmentsEqual(p,f),p=f,!u){let y=this.updateCentroids(a,p,n);this.maxCentroidMovement(d,y)<i&&(u=!0),d=y}h++}let g=[],m=new Map;for(let f=0;f<n;f++){let y=[],E=[];for(let x=0;x<p.length;x++)p[x]===f&&(y.push(l[x]),E.push(a[x]));if(y.length>0){let x=`cluster-${f}`,J=this.calculateVariance(E,d[f]);g.push({id:x,centroid:d[f],members:y,variance:J});for(let Y of y)m.set(Y,x)}}return{clusters:g,assignments:m,iterations:h}}dbscan(e,t){let{eps:n,minPts:s}=t,i=Array.from(e.entries()),r=i.map(([g])=>g),o=i.map(([,g])=>g),l=o.length,a=new Array(l).fill(-2),d=0;for(let g=0;g<l;g++){if(a[g]!==-2)continue;let m=this.regionQuery(o,g,n);m.length<s?a[g]=-1:(this.expandCluster(o,a,g,m,d,n,s),d++)}let p=new Map,h=new Map;for(let g=0;g<l;g++){let m=a[g];if(m>=0){let f=p.get(m)||[];f.push(r[g]),p.set(m,f),h.set(r[g],`cluster-${m}`)}}let u=[];for(let[g,m]of p){let f=m.map(x=>e.get(x)),y=P(f),E=this.calculateVariance(f,y);u.push({id:`cluster-${g}`,centroid:y,members:m,variance:E})}return{clusters:u,assignments:h}}calculateDensity(e,t){if(e.members.length===0)return 0;let n=0;for(let a of e.members){let d=t.get(a);d&&(n+=C(d,e.centroid))}let s=n/e.members.length,i=Array.from(t.values()),r=P(i),o=0;for(let a of i)o+=C(a,r);if(o/=i.length,o===0)return 1;let l=s/o;return Math.max(0,Math.min(1,1-l/2))}cosineSimilarity(e,t){return W(e,t)}euclideanDistance(e,t){return C(e,t)}findOptimalK(e,t,n){let s=[];for(let o=t;o<=n;o++){let a=this.kMeans(e,{k:o,maxIterations:50}).clusters.reduce((d,p)=>d+p.variance*p.members.length,0);s.push(a)}let i=0,r=t;for(let o=1;o<s.length-1;o++){let l=Math.abs(s[o-1]-2*s[o]+s[o+1]);l>i&&(i=l,r=t+o)}return r}kMeansPlusPlusInit(e,t){let n=[],s=e.length,i=Math.floor(Math.random()*s);n.push([...e[i]]);for(let r=1;r<t;r++){let o=e.map(d=>{let p=Math.min(...n.map(h=>C(d,h)));return p*p}),l=o.reduce((d,p)=>d+p,0),a=Math.random()*l;for(let d=0;d<s;d++)if(a-=o[d],a<=0){n.push([...e[d]]);break}}return n}randomInit(e,t){let n=[],s=new Set;for(;s.size<t;)s.add(Math.floor(Math.random()*e.length));for(let i of s)n.push([...e[i]]);return n}findNearestCentroid(e,t){let n=1/0,s=0;for(let i=0;i<t.length;i++){let r=C(e,t[i]);r<n&&(n=r,s=i)}return s}updateCentroids(e,t,n){let s=e[0].length,i=[];for(let r=0;r<n;r++){let o=e.filter((l,a)=>t[a]===r);o.length>0?i.push(P(o)):i.push(new Array(s).fill(0))}return i}assignmentsEqual(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}maxCentroidMovement(e,t){let n=0;for(let s=0;s<e.length;s++){let i=C(e[s],t[s]);i>n&&(n=i)}return n}calculateVariance(e,t){if(e.length===0)return 0;let n=0;for(let s of e){let i=C(s,t);n+=i*i}return n/e.length}createSinglePointClusters(e){let t=[],n=new Map,s=0;for(let[i,r]of e){let o=`cluster-${s}`;t.push({id:o,centroid:r,members:[i],variance:0}),n.set(i,o),s++}return{clusters:t,assignments:n}}regionQuery(e,t,n){let s=[];for(let i=0;i<e.length;i++)C(e[t],e[i])<=n&&s.push(i);return s}expandCluster(e,t,n,s,i,r,o){t[n]=i;let l=[...s];for(;l.length>0;){let a=l.shift();if(t[a]===-1&&(t[a]=i),t[a]!==-2)continue;t[a]=i;let d=this.regionQuery(e,a,r);d.length>=o&&l.push(...d)}}};var F=class{constructor(e={}){this.config={apiKey:e.apiKey||"",model:e.model||"gpt-4o-mini",maxTokens:e.maxTokens||500,temperature:e.temperature||.7}}setApiKey(e){this.config.apiKey=e}isAvailable(){return this.config.apiKey.length>0}async inferTopic(e,t){if(!this.isAvailable())return{topic:"Unknown",confidence:0,reasoning:"LLM service not configured - API key missing"};let n=`You are a knowledge management expert analyzing a personal knowledge base.
Your task is to infer what topic or concept connects a group of notes.

Analyze the notes and determine:
1. What theme or topic connects these notes?
2. How confident are you in this inference?

Be concise. Return JSON format: {"topic": "topic name", "confidence": 0.0-1.0, "reasoning": "brief explanation"}`,s=t&&t.length>0?`

Note Excerpts:
${t.map((r,o)=>`${o+1}. ${r.slice(0,200)}`).join(`
`)}`:"",i=`Note Titles:
${e.map((r,o)=>`${o+1}. ${r}`).join(`
`)}
${s}

What topic connects these notes? Return JSON.`;try{let r=await this.callOpenAI([{role:"system",content:n},{role:"user",content:i}]),o=r.match(/\{[\s\S]*\}/);if(o){let l=JSON.parse(o[0]);return{topic:l.topic||"Unknown",confidence:Math.min(1,Math.max(0,l.confidence||.5)),reasoning:l.reasoning}}return{topic:r.split(`
`)[0].replace(/["']/g,"").trim()||"Unknown",confidence:.5,reasoning:r}}catch(r){return{topic:"Unknown",confidence:0,reasoning:r instanceof Error?r.message:"Unknown error occurred"}}}async generateExplorationSuggestions(e,t,n){if(!this.isAvailable())return[];let s=`You are a knowledge management expert helping expand a personal knowledge base.
Given a knowledge gap, suggest specific topics, questions, and subtopics to explore.

Return JSON array: [{"topic": "...", "questions": ["..."], "subtopics": ["..."], "rationale": "..."}]`,i=t.length>0?`

Related existing notes:
${t.slice(0,10).map(l=>`- ${l}`).join(`
`)}`:"",r=n?`

Additional context: ${n}`:"",o=`Knowledge Gap: ${e}
${i}${r}

Suggest 2-3 exploration areas with questions and subtopics. Return JSON array.`;try{let l=await this.callOpenAI([{role:"system",content:s},{role:"user",content:o}]),a=l.match(/\[[\s\S]*\]/);return a?JSON.parse(a[0]).map(p=>({topic:p.topic||"",questions:p.questions||[],subtopics:p.subtopics||[],rationale:p.rationale||""})):[{topic:e,questions:this.extractBullets(l),subtopics:[],rationale:l.slice(0,200)}]}catch(l){return console.error("Failed to generate exploration suggestions:",l),[]}}async describeUndefinedConcept(e,t){if(!this.isAvailable())return`${e} is a concept referenced in your notes that may warrant further exploration.`;let n=`You are a knowledge management expert helping create new notes.
Given a concept name and the notes that reference it, provide a brief description suitable for a new note.

Be concise (2-3 sentences). Focus on what this concept likely means based on context.`,s=`Concept: "${e}"

Referenced in these notes:
${t.slice(0,10).map(i=>`- ${i}`).join(`
`)}

Provide a brief description of what this concept might be about.`;try{return(await this.callOpenAI([{role:"system",content:n},{role:"user",content:s}])).trim()||`${e} is a concept referenced in your notes.`}catch(i){return console.error("Failed to describe concept:",i),`${e} is a concept referenced in your notes that may warrant further exploration.`}}async generate(e,t){if(!this.isAvailable())return{success:!1,error:"LLM service not configured - API key missing"};let n=[];t&&n.push({role:"system",content:t}),n.push({role:"user",content:e});try{let s=await this.callOpenAIWithUsage(n);return{success:!0,content:s.content,usage:s.usage}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Unknown error occurred"}}}async callOpenAI(e){return(await this.callOpenAIWithUsage(e)).content}async callOpenAIWithUsage(e){var s,i;let t=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.config.apiKey}`},body:JSON.stringify({model:this.config.model,messages:e,max_tokens:this.config.maxTokens,temperature:this.config.temperature})});if(!t.ok){let r=await t.text();throw new Error(`OpenAI API error: ${t.status} - ${r}`)}let n=await t.json();return{content:((i=(s=n.choices[0])==null?void 0:s.message)==null?void 0:i.content)||"",usage:n.usage?{promptTokens:n.usage.prompt_tokens,completionTokens:n.usage.completion_tokens,totalTokens:n.usage.total_tokens}:void 0}}extractBullets(e){let t=[],n=e.split(`
`);for(let s of n){let i=s.trim();if(i.match(/^[-*•]\s+/)||i.match(/^\d+\.\s+/)){let r=i.replace(/^[-*•]\s+/,"").replace(/^\d+\.\s+/,"").trim();r.length>0&&t.push(r)}}return t}};var O=class extends b.Plugin{constructor(){super(...arguments);this.isAnalyzing=!1;this.lastReport=null}async onload(){console.log("Loading Knowledge Gap Detector plugin"),await this.loadSettings(),this.initializeServices(),this.addSettingTab(new T(this.app,this)),this.registerCommands(),this.addRibbonIcon("search","Analyze Knowledge Gaps",async()=>{await this.runAnalysis()}),this.checkAutoAnalysis()}onunload(){console.log("Unloading Knowledge Gap Detector plugin")}async loadSettings(){this.settings=Object.assign({},A,await this.loadData())}async saveSettings(){await this.saveData(this.settings),this.llmService&&this.llmService.setApiKey(this.settings.openaiApiKey)}initializeServices(){this.embeddingReader=new N(this.app.vault),this.linkGraphReader=new D(this.app.vault),this.clusteringService=new U,this.llmService=new F({apiKey:this.settings.openaiApiKey,model:this.settings.llmModel}),this.linkGraphReader.setExcludeFolders(this.settings.excludeFolders),this.detectSparseRegionsUseCase=new k(this.embeddingReader,this.clusteringService),this.findUndefinedConceptsUseCase=new R(this.linkGraphReader),this.analyzeGapsUseCase=new L(this.embeddingReader,this.linkGraphReader,this.clusteringService,this.llmService)}registerCommands(){this.addCommand({id:"analyze-knowledge-gaps",name:"Analyze Knowledge Gaps",callback:()=>this.runAnalysis()}),this.addCommand({id:"show-gap-report",name:"Show Last Gap Report",callback:()=>this.showLastReport()}),this.addCommand({id:"find-undefined-concepts",name:"Find Undefined Concepts",callback:()=>this.findUndefinedConcepts()}),this.addCommand({id:"detect-sparse-regions",name:"Detect Sparse Regions",callback:()=>this.detectSparseRegions()}),this.addCommand({id:"clear-analysis-cache",name:"Clear Analysis Cache",callback:()=>this.clearCache()})}async runAnalysis(){if(this.isAnalyzing){new b.Notice("Analysis already in progress...");return}if(!await this.embeddingReader.isAvailable()){new b.Notice("Vault Embeddings not found. Please install and run the Vault Embeddings plugin first.",1e4);return}this.isAnalyzing=!0;let n=new b.Notice("Analyzing knowledge gaps...",0);try{this.linkGraphReader.setExcludeFolders(this.settings.excludeFolders);let s=await this.analyzeGapsUseCase.execute({clusterCount:this.settings.clusterCount,sparsityThreshold:this.settings.sparseDensityThreshold,minMentions:this.settings.minMentionsForUndefined,useLLM:this.settings.enableLLMSuggestions&&this.llmService.isAvailable(),maxGaps:this.settings.maxGapsInReport,excludeFolders:this.settings.excludeFolders});this.lastReport=s,this.settings.lastAnalyzedAt=Date.now(),await this.saveSettings(),n.hide(),new S(this.app,s).open();let i=s.gaps.filter(r=>r.severity==="significant").length;new b.Notice(`Analysis complete: ${s.gaps.length} gaps found (${i} significant)`)}catch(s){n.hide(),console.error("Knowledge gap analysis failed:",s),new b.Notice(`Analysis failed: ${s instanceof Error?s.message:"Unknown error"}`)}finally{this.isAnalyzing=!1}}showLastReport(){if(!this.lastReport){new b.Notice('No analysis report available. Run "Analyze Knowledge Gaps" first.');return}new S(this.app,this.lastReport).open()}async findUndefinedConcepts(){let t=new b.Notice("Finding undefined concepts...",0);try{this.linkGraphReader.setExcludeFolders(this.settings.excludeFolders);let n=await this.findUndefinedConceptsUseCase.execute({minMentions:this.settings.minMentionsForUndefined,maxConcepts:this.settings.maxGapsInReport,excludeFolders:this.settings.excludeFolders});if(t.hide(),n.length===0)new b.Notice("No undefined concepts found!");else{let s={gaps:[],sparseRegions:[],undefinedConcepts:n,analyzedAt:new Date,totalNotesAnalyzed:0,totalEmbeddings:0,options:{}};new S(this.app,s).open(),new b.Notice(`Found ${n.length} undefined concepts`)}}catch(n){t.hide(),console.error("Find undefined concepts failed:",n),new b.Notice(`Failed: ${n instanceof Error?n.message:"Unknown error"}`)}}async detectSparseRegions(){if(!await this.embeddingReader.isAvailable()){new b.Notice("Vault Embeddings not found. Please install and run the Vault Embeddings plugin first.",1e4);return}let n=new b.Notice("Detecting sparse regions...",0);try{let s=await this.detectSparseRegionsUseCase.execute({clusterCount:this.settings.clusterCount,sparsityThreshold:this.settings.sparseDensityThreshold,excludeFolders:this.settings.excludeFolders});if(n.hide(),s.length===0)new b.Notice("No sparse regions detected!");else{let i={gaps:[],sparseRegions:s,undefinedConcepts:[],analyzedAt:new Date,totalNotesAnalyzed:0,totalEmbeddings:0,options:{}};new S(this.app,i).open(),new b.Notice(`Found ${s.length} sparse regions`)}}catch(s){n.hide(),console.error("Detect sparse regions failed:",s),new b.Notice(`Failed: ${s instanceof Error?s.message:"Unknown error"}`)}}clearCache(){this.embeddingReader.clearCache(),this.linkGraphReader.clearCache(),this.lastReport=null,new b.Notice("Analysis cache cleared")}checkAutoAnalysis(){if(!this.settings.autoAnalyze)return;let t=this.settings.lastAnalyzedAt;if(!t){setTimeout(()=>this.runAnalysis(),5e3);return}let n=this.settings.analyzeIntervalDays*24*60*60*1e3;Date.now()-t>=n&&setTimeout(()=>{new b.Notice("Running scheduled knowledge gap analysis...",3e3),this.runAnalysis()},5e3)}};
